# Download and install

```C
    git clone https://github.com/emscripten-core/emsdk.git
    cd emsdk
    git pull
    ./emsdk install latest

    # Make the "latest" SDK "active" for the current user. (writes ~/.emscripten file)
    ./emsdk activate latest

    # Activate PATH and other environment variables in the current terminal
    source ./emsdk_env.sh
```

## Platform-specific notes

```C
    sudo apt-get install python2.7
    sudo apt-get install nodejs

    # Install CMake (optional, only needed for tests and building Binaryen)
    sudo apt-get install cmake
```

Your system may provide Node.js as node instead of nodejs. In that case, you may need to also update the NODE_JS attribute of your ~/.emscripten file.

# Uninstalling the Emscripten SDK

If you want to remove the whole SDK, just delete the directory containing the SDK.

# Tutorial

```C
./emcc -v
```

```C
#include <stdio.h>

int main() {
  printf("hello, world!\n");
  return 0;
}
```

```C
./emcc tests/hello_world.c
```

You should see two files generated by that command: a.out.js and a.out.wasm. The second is a WebAssembly file containing the compiled code, and the first is a JavaScript file containing the runtime support to load and execute it. You can run them using node.js:

```C
node a.out.js
```

If an error occurs when calling emcc, run it with the -v option to print out a lot of useful debug information.

## Generating HTML

```C
./emcc tests/hello_world.c -o hello.html
```

Unfortunately several browsers (including Chrome, Safari, and Internet Explorer) do not support file:// XHR requests, and can’t load extra files needed by the HTML (like a .wasm file, or packaged file data as mentioned lower down). For these browsers you’ll need to serve the files using a webserver. The easiest way to do this is to use the python SimpleHTTPServer (in the current directory do python -m SimpleHTTPServer 8080 and then open http://localhost:8080/hello.html).

```C
./emcc tests/hello_world_sdl.cpp -o hello.html
```

```C
#include <stdio.h>
#include <SDL/SDL.h>

#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#endif

extern "C" int main(int argc, char** argv) {
  printf("hello, world!\n");

  SDL_Init(SDL_INIT_VIDEO);
  SDL_Surface *screen = SDL_SetVideoMode(256, 256, 32, SDL_SWSURFACE);

#ifdef TEST_SDL_LOCK_OPTS
  EM_ASM("SDL.defaults.copyOnLock = false; SDL.defaults.discardOnLock = true; SDL.defaults.opaqueFrontBuffer = false;");
#endif

  if (SDL_MUSTLOCK(screen)) SDL_LockSurface(screen);
  for (int i = 0; i < 256; i++) {
    for (int j = 0; j < 256; j++) {
#ifdef TEST_SDL_LOCK_OPTS
      // Alpha behaves like in the browser, so write proper opaque pixels.
      int alpha = 255;
#else
      // To emulate native behavior with blitting to screen, alpha component is ignored. Test that it is so by outputting
      // data (and testing that it does get discarded)
      int alpha = (i+j) % 255;
#endif
      *((Uint32*)screen->pixels + i * 256 + j) = SDL_MapRGBA(screen->format, i, j, 255-i, alpha);
    }
  }
  if (SDL_MUSTLOCK(screen)) SDL_UnlockSurface(screen);
  SDL_Flip(screen); 

  printf("you should see a smoothly-colored square - no sharp lines but the square borders!\n");
  printf("and here is some text that should be HTML-friendly: amp: |&| double-quote: |\"| quote: |'| less-than, greater-than, html-like tags: |<cheez></cheez>|\nanother line.\n");

  SDL_Quit();

  return 0;
}
```

Your C/C++ code can access files using the normal libc stdio API (fopen, fclose, etc.)

JavaScript is usually run in the sandboxed environment of a web browser, without direct access to the local file system. Emscripten simulates a file system that you can access from your compiled C/C++ code using the normal libc stdio API.

Files that you want to access should be preloaded or embedded into the virtual file system. Preloading (or embedding) generates a virtual file system that corresponds to the file system structure at compile time, relative to the current directory.

The hello_world_file.cpp example shows how to load a file (both the test code and the file to be loaded shown below):

// Copyright 2012 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

#include <stdio.h>
int main() {
  FILE *file = fopen("tests/hello_world_file.txt", "rb");
  if (!file) {
    printf("cannot open file\n");
    return 1;
  }
  while (!feof(file)) {
    char c = fgetc(file);
    if (c != EOF) {
      putchar(c);
    }
  }
  fclose (file);
  return 0;
}

==
This data has been read from a file.
The file is readable as if it were at the same location in the filesystem, including directories, as in the local filesystem where you compiled the source.
==

Note

The example expects to be able to load a file located at tests/hello_world_file.txt:

FILE *file = fopen("tests/hello_world_file.txt", "rb");

We compile the example from the directory “above” tests to ensure that virtual filesystem is created with the correct structure relative to the compile-time directory.

The following command is used to specify a data file to preload into Emscripten’s virtual file system — before running any compiled code. This approach is useful because Browsers can only load data from the network asynchronously (except in Web Workers) while a lot of native code uses synchronous file system access. Preloading ensures that the asynchronous download of data files is complete (and the file is available) before compiled code has the opportunity to access the Emscripten file system.

./emcc tests/hello_world_file.cpp -o hello.html --preload-file tests/hello_world_file.txt

Run the above command, then open hello.html in a web browser to see the data from hello_world_file.txt being displayed.

For more information about working with the file system see the File System Overview, File System API and Synchronous Virtual XHR Backed File System Usage.
Optimizing code

Emscripten, like gcc and clang, generates unoptimized code by default. You can generate slightly-optimized code with the -O1 command line argument (run the test code from the SDK root directory):

./emcc -O1 tests/hello_world.cpp

The “hello world” code created in a.out.js doesn’t really need to be optimized, so you won’t see a difference in speed when compared to the unoptimized version.

However, you can compare the generated code to see the differences. -O1 applies several minor optimizations and removes some runtime assertions. For example, printf will have been replaced by puts in the generated code.

The optimizations provided by -O2 (see here) are much more aggressive. If you run the following command and inspect the generated code (a.out.js) you will see that it looks very different:

./emcc -O2 tests/hello_world.cpp

For more information about compiler optimization options see Optimizing Code and the emcc tool reference.
Emscripten Test Suite and Benchmarks

Emscripten has a comprehensive test suite, which covers virtually all Emscripten functionality. These tests are an excellent resource for developers as they provide practical examples of most features, and are known to build successfully on the master branch.

See Emscripten Test Suite for more information.
General tips and next steps

This tutorial walked you through your first steps in calling Emscripten from the command line. There is, of course, far more you can do with the tool. Below are other general tips for using Emscripten:

    This site has lots more information about compiling and building projects, integrating your native code with the web environment, packaging your code and publishing.
    The Emscripten test suite is a great place to look for examples of how to use Emscripten. For example, if you want to better understand how the emcc --pre-js option works, search for --pre-js in the test suite: the test suite is extensive and there are likely to be at least some examples.
    To learn how to use Emscripten in advanced ways, read src/settings.js and emcc which describe the compiler options, and emscripten.h for details on JavaScript-specific C APIs that your C/C++ programs can use when compiled with Emscripten.
    Read the FAQ.
    When in doubt, get in touch!

Report Bug Licensing Contributing Mailing list Wiki Release notes Blogs Contact

    View page source
    About site
    Page bug

© Copyright 2015, Emscripten Contributors.


Logo

    Introducing Emscripten
    Getting Started
        Download and install
        Emscripten Tutorial
        Emscripten Test Suite
            Running tests
            Skipping Tests
            Running a bunch of random tests
            Important Tests
            Benchmarking
            Debugging test failures
        Bug Reporting
        FAQ
    Compiling and Running Projects
    Porting
    API Reference
    Tools Reference
    Optimizing Code
    Optimizing WebGL
    CyberDWARF Debugging
    Building Emscripten from Source
    Contributing to Emscripten
    Profiling the Toolchain
    About this site

Index
 
Fork me on GitHub

    Documentation Downloads Community 

Home » Getting Started » Emscripten Test Suite
Emscripten Test Suite

Emscripten has a comprehensive test suite, which covers virtually all Emscripten functionality. These tests are an excellent resource for developers as they provide practical examples of most features, and are known to pass on the master branch (and almost always on the incoming branch). In addition to correctness tests, there are also benchmarks that you can run.

This article explains how to run the test and benchmark suite, and provides an overview of what tests are available.
Running tests

Run the test suite runner (tests/runner.py) with no arguments to see the help message:

python tests/runner.py

The tests are divided into modes. You can run either an entire mode or an individual test, or use wildcards to run some tests in some modes. For example:

# run one test (in the default mode)
python tests/runner.py test_loop

# run one test in a specific mode (here, asm.js -O2)
python tests/runner.py asm2.test_loop

# run a test in a bunch of modes (here, all asm.js modes)
python tests/runner.py asm*.test_loop

# run a bunch of tests in one mode (here, all i64 tests in wasm -O3)
python tests/runner.py binaryen3.test_*i64*

# run all tests in a specific mode (here, asm.js -O1)
python tests/runner.py asm1

The core test modes (asm* and binaryen*, defined in tests/test_core.py) let you run a specific test in either asm.js or wasm, and with different optimization flags. There are also non-core test modes, that run tests in more special manner (in particular, in those tests it is not possible to say “run the test with a different optimization flag” - that is what the core tests are for). The non-core test modes include

        other: Non-core tests running in the shell.
        browser: Tests that run in a browser.
        sockets: Networking tests that run in a browser.
        interactive: Browser tests that are not fully automated, and require user interaction (these should be automated eventually).
        sanity: Tests for emscripten setting itself up. This modifies your .emscripten file temporarily.
        benchmark: Runs benchmarks, measuring speed and code size.

The wildcards we mentioned above work for non-core test modes too, for example:

# run one browser test
python tests/runner.py browser.test_sdl_image

# run all SDL2 browser tests
python tests/runner.py browser.test_sdl2*

# run all browser tests
python tests/runner.py browser

Skipping Tests

An individual test can be skipped by passing the “skip:” prefix. E.g.

python tests/runner.py other skip:other.test_cmake

Wildcards can also be passed in skip, so

python tests/runner.py browser skip:browser.test_pthread_*

will run the whole browser suite except for all the pthread tests in it.
Running a bunch of random tests

You can run a random subset of the test suite, using something like

python tests/runner.py random100

Replace 100 with another number as you prefer. This will run that number of random tests, and tell you the statistical likelihood of almost all the test suite passing assuming those tests do. This works just like election surveys do - given a small sample, we can predict fairly well that so-and-so percent of the public will vote for candidate A. In our case, the “candidates” are pass or fail, and we can predict how much of the test suite will pass given that sample. Assuming the sample tests all pass, we can say with high likelihood that most of the test suite will in fact pass. (Of course, this is no guarantee, and even a single test failure is serious, however, this gives a quick estimate that your patch does not cause significant and obvious breakage.)
Important Tests

When you want to run the entire test suite locally, these are the important commands:

# Run all core asm.js and wasm tests
python tests/runner.py asm* binaryen*

# Run "other" test suite
python tests/runner.py other

# Run "browser" test suite - this requires a web browser
python tests/runner.py browser

# Run "sockets" test suite - this requires a web browser too
python tests/runner.py sockets

# Run "sanity" test suite - this tests setting up emscripten during
# first run, etc., and so it modifies your .emscripten file temporarily.
python tests/runner.py sanity

# Optionally, also run benchmarks to check for regressions
python tests/runner.py benchmark

Benchmarking

Emscripten has a benchmark suite that measures both speed and code size. To run it, do:

# Run all benchmarks
python tests/runner.py benchmark

Usually you will want to customize the python in tests/test_benchmark.py to run the benchmarks you want, see benchmarkers in the source code.
Debugging test failures

Setting the Debug mode (EMCC_DEBUG) is useful for debugging tests, as it emits debug output and intermediate files (the files go in /tmp/emscripten_temp/):

# On Windows, use "set" to set and un-set the EMCC_DEBUG environment variable:
set EMCC_DEBUG=1
python tests/runner.py test_hello_world
set EMCC_DEBUG=0

# On Linux, you can do this all in one line
EMCC_DEBUG=1 python tests/runner.py test_hello_world

# EMCC_DEBUG=2 generates additional debug information.
EMCC_DEBUG=2 python tests/runner.py test_hello_world

You can also specify EMTEST_SAVE_DIR=1 in the environment to save the temporary directory that the test runner uses into /tmp/emscripten_test/. This is a test suite-specific feature, and is useful for tests that create temporary files.

The Debugging topic provides more guidance on how to debug Emscripten-generated code.
Report Bug Licensing Contributing Mailing list Wiki Release notes Blogs Contact

    View page source
    About site
    Page bug

© Copyright 2015, Emscripten Contributors.


Logo

    Introducing Emscripten
    Getting Started
        Download and install
        Emscripten Tutorial
        Emscripten Test Suite
        Bug Reporting
        FAQ
            How do I compile code?
            Why do I get multiple errors building basic code and the tests?
            I tried something: why doesn’t it work?
            Do I need to change my build system to use Emscripten?
            Why is code compilation slow?
            Why does my code run slowly?
            Why is my compiled code big?
            Why does compiling code that works on another machine gives me errors?
            How can I reduce startup time?
            What is “No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead” or “no native wasm support detected”?
            Why does my code fail to compile with an error message about inline assembly (or {"text":"asm"})?
            Why does my HTML app hang?
            How do I run an event loop?
            Why doesn’t my SDL app work?
            How do I link against system libraries like SDL, boost, etc.?
            What are my options for audio playback?
            How can my compiled program access files?
            Why can’t my code access a file in the same directory?
            How can I tell when the page is fully loaded and it is safe to call compiled functions?
            What does “exiting the runtime” mean? Why don’t atexit()s run?
            Why do functions in my C/C++ source code vanish when I compile to JavaScript, and/or I get No functions to process?
            Why is the File System API is not available when I build with closure?
            Why does my code break and gives odd errors when using -O2 --closure 1?
            Why do I get TypeError: Module.someThing is not a function?
            Why does Runtime no longer exist? Why do I get an error trying to access Runtime.someThing?
            Why do I get a NameError or a problem occurred in evaluating content after a "-s" when I use a -s option?
            Why do I get an odd python error complaining about libcxx.bc or libcxxabi.bc?
            Why do I get an error mentioning Uglify and throw new JS_Parse_Error?
            Why does running LLVM bitcode generated by emcc through lli break with errors about impure_ptr?
            Why do I get a stack size error when optimizing: RangeError: Maximum call stack size exceeded or similar?
            Why do I get error: cannot compile this aggregate va_arg expression yet and it says compiler frontend failed to generate LLVM bitcode, halting afterwards?
            Why does building from source fail during linking (at 100%)?
            Why do I get odd rounding errors when using float variables?
            How do I pass int64_t and uint64_t values from js into wasm functions?
            Can I use multiple Emscripten-compiled programs on one Web page?
            Can I build JavaScript that only runs on the Web?
            Why the weird name for the project?
    Compiling and Running Projects
    Porting
    API Reference
    Tools Reference
    Optimizing Code
    Optimizing WebGL
    CyberDWARF Debugging
    Building Emscripten from Source
    Contributing to Emscripten
    Profiling the Toolchain
    About this site

Index
 
Fork me on GitHub

    Documentation Downloads Community 

Home » Getting Started » FAQ
FAQ

This FAQ contains answers to many questions asked on IRC and the mailing list.
How do I compile code?

See the Emscripten Tutorial and emcc.
Why do I get multiple errors building basic code and the tests?

All the tests in the Emscripten test suite are known to build and pass on the master branch, so if these are failing it is likely that there is some problem with your environment.

First call ./emcc -v, which runs basic sanity checks and prints out useful environment information. If that doesn’t help, follow the instructions in Verifying the Emscripten Development Environment.

You might also want to go through the Emscripten Tutorial again, as this is updated as Emscripten changes.
I tried something: why doesn’t it work?

Some general steps that might help figure things out:

        See if the problem happens without optimizations (-O0, or not specifying any optimization level). Without optimizations, emscripten enables many assertions at compile and runtime, which may catch a problem and display an error message with a suggestion for how to fix it.
        Search the documentation on this site.
        Check if there is a test for the failing functionality in the Emscripten test suite (run grep -r in tests/). They should all pass (with only rare exceptions), so they provide concrete “known-good” examples of how various options and code are used.

Do I need to change my build system to use Emscripten?

In most cases you will be able to use your project’s current build system with Emscripten. See Building Projects.
Why is code compilation slow?

Emscripten makes some trade-offs that make the generated code faster and smaller, at the cost of longer compilation times. For example, we build parts of the standard library along with your code, which enables some additional optimizations, but takes a little longer to compile.

Note

You can determine what compilation steps take longest by compiling with EMCC_DEBUG=1 in the environment and then reviewing the debug logs (by default in /tmp/emscripten_temp). Note that compiling in debug mode takes longer than normal, because we print out a lot of intermediate steps to disk.

The main tips for improving build time are:

    Create fully optimized builds less frequently — use -O0 during frequent development iterations (or don’t specify an optimization level).
        Compiling with higher levels of optimization can in some cases be noticeably slower: -O2 is slower than -O1, which is in turn slower than -O0.
        Compiling with -O3 is especially slow — this can be mitigated by also enabling -s AGGRESSIVE_VARIABLE_ELIMINATION=1 (removing variables makes the -O3 regalloc easier).
    Compile without line number debug information (use -O1 or -g0 instead of -g):
        Currently builds with line-number debug information are slow (see issue #216). Stripping the debug information significantly improves compile times.
    Compile on a machine with more cores:
        Emscripten can run some passes in parallel (specifically, the JavaScript optimisations). Increasing the number of cores results in an almost linear improvement.
        Emscripten will automatically use more cores if they are available. You can control how many cores are used with EMCC_CORES=N (this is useful if you have many cores but relatively less memory).
    Make sure that the native optimizer is being used, which greatly speeds up optimized builds as of 1.28.2. EMCC_DEBUG=1 output should not report errors about the native optimizer failing to build or not being used because of a previous failed build (if it previously failed, do emcc --clear-cache then compile your file again, and the optimizer will be automatically rebuilt).
    When you have multiple bitcode files as inputs, put the largest file first (LLVM linking links the second and later ones into the first, so less copying is done on the first input to the linker).
    Having fewer bitcode files can be faster, so you might want to link files into larger files in parallel in your build system (you might already do this if you have logical libraries), and then the final command has fewer things to operate on.
    You don’t need to link into a single bitcode file yourself, you can call the final emcc command that emits JS with a list of files. emcc can then defer linking and avoid an intermediary step, if possible (this optimization is disabled by LTO and by EMCC_DEBUG=2).

Why does my code run slowly?

Make sure you optimize code by building with -O2 (even more aggressive optimization is available, at the cost of significantly increased compilation time).
Why is my compiled code big?

Make sure you build with -O3 or -Os so code is fully optimized and minified. You should use the closure compiler, gzip compression on your webserver, etc., see the section on code size in Optimizing code.
Why does compiling code that works on another machine gives me errors?

Make sure you are using the Emscripten bundled system headers. Using emcc will do so by default, but problems may occur if you use your local system headers with emcc or compile into LLVM bitcode yourself.
How can I reduce startup time?

Make sure that you are running an optimized build (smaller builds are faster to start up).

Network latency is also a possible factor in startup time. Consider putting the file loading code in a separate script element from the generated code so that the browser can start the network download in parallel to starting up the codebase (run the file packager and put file loading code in one script element, and the generated codebase in a later script element).
What is “No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead” or “no native wasm support detected”?

Those errors indicate that WebAssembly support is not present in the VM you are trying to run the code in. Compile with -s WASM=0 to disable WebAssembly (and emit asm.js instead) if you want your code to run in such environments (all modern browsers support WebAssembly, but in some cases you may want to reach 100% of browsers, including legacy ones).
Why does my code fail to compile with an error message about inline assembly (or {"text":"asm"})?

Emscripten cannot compile inline assembly code (because it is CPU specific, and Emscripten is not a CPU emulator).

You will need to find where inline assembly is used, and disable it or replace it with platform-independent code.

Note

Emscripten automatically unsets the following #define values, as these are commonly set in projects to enable platform dependent code (inline assembly):

#undef __i386__
#undef __x86_64__

Why does my HTML app hang?

The browser event model uses co-operative multitasking — each event has a “turn” to run, and must then return control to the browser event loop so that other events can be processed. A common cause of HTML pages hanging is JavaScript that does not complete and return control to the browser.

Graphical C++ apps typically have an infinite main loop in which event handling, processing and rendering is done, followed by a delay to keep the frame-rate right (SDL_DELAY in SDL apps). As the main loop does not complete (is infinite) it cannot return control to the browser, and the app will hang.

Apps that use an infinite main loop should be re-coded to put the actions for a single iteration of the loop into a single “finite” function. In the native build this function can be run in an infinite loop as before. In the Emscripten build it is set as the main loop function and will be called by the browser at a specified frequency.

There is more information on this topic in Emscripten Runtime Environment.
How do I run an event loop?

To run a C function repeatedly, use emscripten_set_main_loop() (this is discussed in Emscripten Runtime Environment). The related functions in emscripten.h are also useful, allowing you to add events that block the main loop, etc.

To respond to browser events use the SDL API in the normal way. There are examples in the SDL tests (search for SDL in tests/runner.py).

See also: Why does my HTML app hang?
Why doesn’t my SDL app work?

See the SDL automatic tests for working examples: python tests/runner.py browser.
How do I link against system libraries like SDL, boost, etc.?

System libraries that are included with Emscripten are automatically linked when you compile (just the necessary parts). This includes libc, libc++ (C++ standard library) and SDL.

Libraries not included with Emscripten (like Boost) must be compiled and linked with the program just as if they were a module in the project.

There is a set of libraries ported to Emscripten for convenient use, Emscripten Ports. See Building Projects

Another option is to implement needed C APIs as JavaScript libraries (see --js-library in emcc and Implement a C API in JavaScript). Emscripten itself does this for libc (not including malloc) and SDL (but not libc++ or malloc).

Note

    Unlike other compilers, you don’t need -lSDL to include SDL (specifying it will do no harm).
    In the specific case of Boost, if you only need the boost headers then you don’t need to compile anything.

What are my options for audio playback?

Emscripten has partial support for SDL1 and 2 audio, and OpenAL.

To use SDL1 audio, include it as #include <SDL/SDL_mixer.h>. You can use it that way alongside SDL1, SDL2, or another library for platform integration.

To use SDL2 audio, include it as #include <SDL2/SDL_mixer.h> and use -s USE_SDL_MIXER=2. Format support is currently limited to OGG and WAV.
How can my compiled program access files?

Emscripten uses a virtual file system that may be preloaded with data or linked to URLs for lazy loading. See the File System Overview for more details.
Why can’t my code access a file in the same directory?

Emscripten-generated code running in the browser cannot access files in the local file system. Instead you can use preloading and embedding to work around the lack of synchronous file IO. See File System Overview for more information.

It is possible to allow access to local file system for code running in node.js, use the NODEFS filesystem option.
How can I tell when the page is fully loaded and it is safe to call compiled functions?

(You may need this answer if you see an error saying something like you need to wait for the runtime to be ready (e.g. wait for main() to be called), which is a check enabled in ASSERTIONS builds.)

Calling a compiled function before a page has fully loaded can result in an error, if the function relies on files that may not be present (for example the .mem file and preloaded files are loaded asynchronously, and therefore if you just place some JS that calls compiled code in a --post-js, that code will be called synchronously at the end of the combined JS file, potentially before the asynchronous event happens, which is bad).

The easiest way to find out when loading is complete is to add a main() function, and within it call a JavaScript function to notify your code that loading is complete.

Note

The main() function is called after startup is complete as a signal that it is safe to call any compiled method.

For example, if allReady() is a JavaScript function you want called when everything is ready, you can do:

#include <emscripten.h>

int main() {
  EM_ASM( allReady() );
}

Another option is to define an onRuntimeInitialized function,

Module['onRuntimeInitialized'] = function() { ... };

That method will be called when the runtime is ready and it is ok for you to call compiled code. In practice, that is exactly the same time at which main() would be called, so onRuntimeInitialized doesn’t let you do anything new, but you can set it from JavaScript at runtime in a flexible way.

Here is an example of how to use it:

<script type="text/javascript">
  var Module = {
    onRuntimeInitialized: function() {
      Module._foobar(); // foobar was exported
    }
  };
</script>
<script type="text/javascript" src="my_project.js"></script>

The crucial thing is that Module exists, and has the property onRuntimeInitialized, before the script containing emscripten output (my_project.js in this example) is loaded.

Another option is to use the MODULARIZE option, using -s MODULARIZE=1. That will put all of the generated JavaScript in a function, which you can call to create an instance. The instance has a promise-like .then() method, so if you build with say -s MODULARIZE=1 -s 'EXPORT_NAME="MyCode"' (see details in settings.js), then you can do something like this:

MyCode().then(function(Module) {
  // this is reached when everything is ready, and you can call methods on Module
});

What does “exiting the runtime” mean? Why don’t atexit()s run?

(You may need this answer if you see an error saying something like atexit() called, but EXIT_RUNTIME is not set or stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1.)

By default Emscripten sets EXIT_RUNTIME=0, which means that we don’t include code to shut down the runtime. That means that when main() exits, we don’t flush the stdio streams, or call the destructors of global C++ objects, or call atexit callbacks. This lets us emit smaller code by default, and is normally what you want on the web: even though main() exited, you may have something asynchronous happening later that you want to execute.

In some cases, though, you may want a more “commandline” experience, where we do shut down the runtime when main() exits. You can build with -s EXIT_RUNTIME=1, and then we will call atexits and so forth. When you build with ASSERTIONS, you should get a warning when you need this. For example, if your program prints something without a newline,

#include <stdio.h>

int main() {
  printf("hello"); // note no newline
}

If we don’t shut down the runtime and flush the stdio streams, “hello” won’t be printed. In an ASSERTIONS build you’ll get a notification saying stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1.
Why do functions in my C/C++ source code vanish when I compile to JavaScript, and/or I get No functions to process?

Emscripten does dead code elimination of functions that are not called from the compiled code. While this does minimize code size, it can remove functions that you plan to call yourself (outside of the compiled code).

To make sure a C function remains available to be called from normal JavaScript, it must be added to the EXPORTED_FUNCTIONS using the emcc command line. For example, to prevent functions my_func() and main() from being removed/renamed, run emcc with:

./emcc -s "EXPORTED_FUNCTIONS=['_main', '_my_func']"  ...

Note

_main should be in the export list, as in that example, if you have a main() function. Otherwise, it will be removed as dead code; there is no special logic to keep main() alive by default.

Note

EXPORTED_FUNCTIONS affects compilation to JavaScript. If you first compile to an object file, then compile the object to JavaScript, you need that option on the second command.

If your function is used in other functions, LLVM may inline it and it will not appear as a unique function in the JavaScript. Prevent inlining by defining the function with EMSCRIPTEN_KEEPALIVE:

void EMSCRIPTEN_KEEPALIVE yourCfunc() {..}

EMSCRIPTEN_KEEPALIVE also exports the function, as if it were on EXPORTED_FUNCTIONS.

Note

    All functions not kept alive through EXPORTED_FUNCTIONS or EMSCRIPTEN_KEEPALIVE will potentially be removed. Make sure you keep the things you need alive using one or both of those methods.
    Exported functions need to be C functions (to avoid C++ name mangling).
    Decorating your code with EMSCRIPTEN_KEEPALIVE can be useful if you don’t want to have to keep track of functions to export explicitly, and when these exports do not change. It is not necessarily suitable for exporting functions from other libraries — for example it is not a good idea to decorate and recompile the source code of the C standard library. If you build the same source in multiple ways and change what is exported, then managing exports on the command line is easier.
    Running emcc with -s LINKABLE=1 will also disable link-time optimizations and dead code elimination. This is not recommended as it makes the code larger and less optimized.

Another possible cause of missing code is improper linking of .a files. The .a files link only the internal object files needed by previous files on the command line, so the order of files matters, and this can be surprising. If you are linking .a files, make sure they are at the end of the list of files, and in the right order amongst themselves. Alternatively, just use .so files instead in your project.

Tip

It can be useful to compile with EMCC_DEBUG=1 set for the environment (EMCC_DEBUG=1 emcc ... on Linux, set EMMCC_DEBUG=1 on Windows). This splits up the compilation steps and saves them in /tmp/emscripten_temp. You can then see at what stage the code vanishes (you will need to do llvm-dis on the bitcode stages to read them, or llvm-nm, etc.).
Why is the File System API is not available when I build with closure?

The Closure Compiler will minify the File Server API code. Code that uses the file system must be optimized with the File System API, using emcc’s --pre-js option.
Why does my code break and gives odd errors when using -O2 --closure 1?

The Closure Compiler minifies variable names, which results in very short variable names like i, j, xa, etc. If other code declares variables with the same names in global scope, this can cause serious problems.

This is likely to be the cause if you can successfully run code compiled with -O2 set and --closure unset.

One solution is to stop using small variable names in the global scope (often this is a mistake — forgetting to use var when assigning to a variable).

Another alternative is to wrap the generated code (or your other code) in a closure, as shown:

var CompiledModule = (function() {
  .. GENERATED CODE ..
  return Module;
  })();

Why do I get TypeError: Module.someThing is not a function?

The Module object will contain exported methods. For something to appear there, you should add it to EXPORTED_FUNCTIONS for compiled code, or EXTRA_EXPORTED_RUNTIME_METHODS for a runtime method (like getValue). For example,

    ./emcc -s "EXPORTED_FUNCTIONS=['_main', '_my_func']" ...

would export a C method my_func (in addition to main, in this example). And

    ./emcc -s "EXTRA_EXPORTED_RUNTIME_METHODS=['ccall']" ...

will export ccall. In both cases you can then access the exported function on the Module object.

Note

You can use runtime methods directly, without exporting them, if the compiler can see them used. For example, you can use getValue in EM_ASM code, or a --pre-js, by calling it directly. The optimizer will not remove that JS runtime method because it sees it is used. You only need to use Module.getValue if you want to call that method from outside the JS code the compiler can see, and then you need to export it.

Note

Emscripten used to export many runtime methods by default. This increased code size, and for that reason we’ve changed that default. If you depend on something that used to be exported, you should see a warning pointing you to the solution, in an unoptimized build, or a build with ASSERTIONS enabled, which we hope will minimize any annoyance. See ChangeLog.md for details.
Why does Runtime no longer exist? Why do I get an error trying to access Runtime.someThing?

1.37.27 includes a refactoring to remove the Runtime object. This makes the generated code more efficient and compact, but requires minor changes if you used Runtime.* APIs. You just need to remove the Runtime. prefix, as those functions are now simple functions in the top scope (an error message in -O0 or builds with assertions enabled with suggest this). In other words, replace

    x = Runtime.stackAlloc(10);

with

    x = stackAlloc(10);

Note

The above will work for code in a --pre-js or JS library, that is, code that is compiled together with the emscripten output. If you try to access Runtime.* methods from outside the compiled code, then you must export that function (using EXTRA_EXPORTED_RUNTIME_METHODS), and use it on the Module object, see that FAQ entry.
Why do I get a NameError or a problem occurred in evaluating content after a "-s" when I use a -s option?

That may occur when running something like

# this fails on most Linuxes
./emcc a.c -s EXTRA_EXPORTED_RUNTIME_METHODS=['addOnPostRun']

# this fails on macOS
./emcc a.c -s EXTRA_EXPORTED_RUNTIME_METHODS="['addOnPostRun']"

You may need to quote things like this:

# this works in the shell on most Linuxes and on macOS
./emcc a.c -s "EXTRA_EXPORTED_RUNTIME_METHODS=['addOnPostRun']"

# or you may need something like this in a Makefile
./emcc a.c -s EXTRA_EXPORTED_RUNTIME_METHODS=\"['addOnPostRun']\"

The proper syntax depends on the OS and shell you are in, and if you are writing in a Makefile, etc.
Why do I get an odd python error complaining about libcxx.bc or libcxxabi.bc?

A possible cause is that building libcxx or libcxxabi failed. Go to system/lib/libcxx (or libcxxabi) and do emmake make to see the actual error. Or, clean the Emscripten cache (./emcc --clear-cache) and then compile your file with EMCC_DEBUG=1 in the environment. libcxx will then be built in /tmp/emscripten_temp/libcxx, and you can see configure*, make* files that are the output of configure and make, etc.

Another possible cause of this error is the lack of make, which is necessary to build these libraries. If you are on Windows, you need cmake.
Why do I get an error mentioning Uglify and throw new JS_Parse_Error?

In -O2 and above, emscripten will optimize the JS using Uglify1. If you added any JS (using --pre-js/--post-js/EM_ASM/EM_JS) and it contains JS that Uglify1 can’t parse - like recent ES6 features - then it will throw such a parsing error.

In the long term we hope to upgrade our internal JS parser. Meanwhile, you can move such code to another script tag on the page, that is, not pass it through the emscripten optimizer.

See also

        https://github.com/emscripten-core/emscripten/issues/6000
        https://github.com/emscripten-core/emscripten/issues/5700

Why does running LLVM bitcode generated by emcc through lli break with errors about impure_ptr?

Note

lli is not maintained, and has odd errors and crashes. We do include tools/nativize_llvm.py (which compiles bitcode to a native executable) but it will also hit the impure_ptr error.

The issue is that newlib uses impure_ptr code, while glibc uses something else. The result is that bitcode built with the Emscripten will not run locally unless your machine uses newlib (basically, only embedded systems).

The impure_ptr error only occurs during explicit use of stdout etc., so printf(..) will work, but fprintf(stdout, ..) will not. Usually it is simple to modify your code to avoid this problem.
Why do I get a stack size error when optimizing: RangeError: Maximum call stack size exceeded or similar?

You may need to increase the stack size for node.js.

On Linux and Mac macOS, you can just do NODE_JS = ['node', '--stack_size=8192'] in the Emscripten Compiler Configuration File (.emscripten). On Windows, you will also need --max-stack-size=8192, and also run editbin /stack:33554432 node.exe.
Why do I get error: cannot compile this aggregate va_arg expression yet and it says compiler frontend failed to generate LLVM bitcode, halting afterwards?

This is a limitation of the asm.js target in Clang. This code is not currently supported.
Why does building from source fail during linking (at 100%)?

Building Fastcomp from source (and hence the SDK) can fail at 100% progress. This is due to out of memory in the linking stage, and is reported as an error: collect2: error: ld terminated with signal 9 [Killed].

The solution is to ensure the system has sufficient memory. On Ubuntu 14.04.1 LTS 64bit, you should use at least 6Gb.
Why do I get odd rounding errors when using float variables?

In asm.js, by default Emscripten uses doubles for all floating-point variables, that is, 64-bit floats even when C/C++ code contains 32-bit floats. This is simplest and most efficient to implement in JS as doubles are the only native numeric type. As a result, you may see rounding errors compared to native code using 32-bit floats, just because of the difference in precision between 32-bit and 64-bit floating-point values.

To check if this is the issue you are seeing, build with -s PRECISE_F32=1. This uses proper 32-bit floating-point values, at the cost of some extra code size overhead. This may be faster in some browsers, if they optimize Math.fround, but can be slower in others. See src/settings.js for more details on this option.

(This is not an issue for wasm, which has native float types.)
How do I pass int64_t and uint64_t values from js into wasm functions?

JS can’t represent int64s, so what happens is that in exported functions (that you can call from JS) we “legalize” the types, by turning an i64 argument into two i32s (low and high bits), and an i64 return value becomes an i32, and you can access the high bits by calling a helper function called getTempRet0.
Can I use multiple Emscripten-compiled programs on one Web page?

Emscripten output by default is just some code. When put in a script tag, that means the code is in the global scope. So multiple such modules on the same page can’t work.

But by putting each module in a function scope, that problem is avoided. Emscripten even has a compile flag for this, MODULARIZE, useful in conjunction with EXPORT_NAME (details in settings.js).

However, there are still some issues if the same Module object (that defines the canvas, text output area, etc.) is used among separate modules. By default Emscripten output even looks for Module in the global scope, but when using MODULARIZE, you get a function you must call with the Module as a param, so that problem is avoided. But note that each module will probably want its own canvas, text output area, etc.; just passing in the same Module object (e.g. from the default HTML shell) may not work.

So by using MODULARIZE and creating a proper Module object for each module, and passing those in, multiple modules can work fine.

Another option is to use an iframe, in which case the default HTML shell will just work, as each will have its own canvas, etc. But this is overkill for small programs, which can run modularly as described above.
Can I build JavaScript that only runs on the Web?

Yes, you can see the ENVIRONMENT option in settings.js. For example, building with emcc -s ENVIRONMENT=web will emit code that only runs on the Web, and does not include support code for Node.js and other environments.

This can be useful to reduce code size, and also works around issues like the Node.js support code using require(), which Webpack will process and include unnecessary code for.
Why the weird name for the project?

I don’t know why; it’s a perfectly cromulent word!
Report Bug Licensing Contributing Mailing list Wiki Release notes Blogs Contact

    View page source
    About site
    Page bug

© Copyright 2015, Emscripten Contributors.

Logo

    Introducing Emscripten
    Getting Started
    Compiling and Running Projects
        Building Projects
            Integrating with a build system
            Emscripten build output files
            Building projects with optimizations
            Building projects with debug information
            Using libraries
            Emscripten Ports
            Build system issues
            Manually using emcc
            Detecting Emscripten in Preprocessor
            Examples / test code
            Troubleshooting
        Building to WebAssembly
        Running HTML files with emrun
        Building projects on Travis CI
        Deploying Emscripten Compiled Pages
    Porting
        Code Portability and Limitations
        Emscripten Runtime Environment
        Connecting C++ and JavaScript
        Files and File Systems
        Multimedia and Graphics
        Audio
        Debugging
        Pthreads support
        Porting SIMD code
        Asyncify
        Emterpreter
        Building Projects
            Integrating with a build system
            Emscripten build output files
            Building projects with optimizations
            Building projects with debug information
            Using libraries
            Emscripten Ports
            Build system issues
            Manually using emcc
            Detecting Emscripten in Preprocessor
            Examples / test code
            Troubleshooting
    API Reference
    Tools Reference
    Optimizing Code
    Optimizing WebGL
    CyberDWARF Debugging
    Building Emscripten from Source
    Contributing to Emscripten
    Profiling the Toolchain
    About this site

Index
 
Fork me on GitHub

    Documentation Downloads Community 

Home » Compiling and Running Projects » Building Projects
Building Projects

Building large projects with Emscripten is very easy. Emscripten provides two simple scripts that configure your makefiles to use emcc as a drop-in replacement for gcc — in most cases the rest of your project’s current build system remains unchanged.
Integrating with a build system

To build using Emscripten you need to replace gcc with emcc in your makefiles. This is done using emconfigure, which sets the appropriate environment variables like CXX (C++ compiler) and CC (the compiler).

Consider the case where you normally build with the following commands:

./configure
make

To build with Emscripten, you would instead use the following commands:

# Run emconfigure with the normal configure command as an argument.
./emconfigure ./configure

# Run emmake with the normal make to generate linked LLVM bitcode.
./emmake make

# Compile the linked bitcode generated by make (project.bc) to JavaScript.
#  'project.bc' should be replaced with the make output for your project (e.g. 'yourproject.so')
#  [-Ox] represents build optimisations (discussed in the next section).
./emcc [-Ox] project.bc -o project.js

emconfigure is called with the normal configure as an argument (in configure-based build systems), and emmake with make as an argument. If your build system uses CMake, replace ./configure with cmake . etc. in the above example. If your build system doesn’t use configure or CMake, then you can omit the first step and just run make (although then you may need to edit the Makefile manually).

Tip

We recommend you call both emconfigure and emmake scripts in configure- and CMake-based build systems. Whether you actually need to call both tools depends on the build system (some systems will store the environment variables in the configure step, and others will not).

Make generates linked LLVM bitcode. It does not automatically generate JavaScript during linking because all the files must be compiled using the same optimizations and compiler options — and it makes sense to do this in the final conversion from bitcode to JavaScript.

Note

The file output from make might have a different suffix: .a for a static library archive, .so for a shared library, .o or .bc for object files (these file extensions are the same as gcc would use for the different types). Irrespective of the file extension, these files contain linked LLVM bitcode that emcc can compile into JavaScript in the final step. If the suffix is something else - like no suffix at all, or something like .so.1 - then you may need to rename the file before sending it to emcc.

Note

Some build systems may not properly emit bitcode using the above procedure, and you may see is not valid bitcode warnings. You can run file to check if a file contains bitcode (also you can manually check if the contents start with BC). It is also worth running emmake make VERBOSE=1 which will print out the commands it runs - you should see emcc being used, and not the native system compiler. If emcc is not used, you may need to modify the configure or cmake scripts.
Emscripten build output files

Emscripten compiler output often consists of several files and not just one. The set of produced files changes depending on the final linker flags passed to emcc/em++. Here is a cheat sheet of which files are produced under which conditions:

        emcc … -o output.html builds a output.html file as an output, as well as an accompanying output.js launcher file, and a output.wasm WebAssembly file.
        emcc … -o output.js omits generating a HTML launcher file (expecting you to provide it yourself if you plan to run in browser), and produces two files, output.js and output.wasm. (that can be run in e.g. node.js shell)
        emcc … -o output.bc does not produce a final asm.js/wasm build, but stops at LLVM bitcode generation stage, and produces a single LLVM bitcode file output.bc. Likewise only one bitcode file is produced if output suffix is .ll, .o, ‘.obj’, ‘.lo’, .lib, .dylib or .so.
        emcc … -o output.a generates a single archive file output.a.
        emcc … -o output.{html,js} -s WASM=0 causes the compiler to target asm.js, and therefore a .wasm file is not produced.
        emcc … -o output.{html,js} -s WASM=0 –separate-asm likewise targets asm.js, but splits up the generated code to two files, output.js and output.asm.js.
        emcc … -o output.html -s WASM=0 -s PRECISE_F32=2 (combination of targeting .html, asm.js and PRECISE_F32=2) implies as if –separate-asm was passed, so also produces output.asm.js.
        emcc … -o output.{html,js} –emit-symbol-map produces a file output.{html,js}.symbols if WebAssembly is being targeted (-s WASM=0 not specified), or if asm.js is being targeted and -Os, -Oz or -O2 or higher is specified, but debug level setting is -g1 or lower (i.e. if symbols minification did occur).
        emcc … -o output.{html,js} -s WASM=0 –memory-init-file 1 causes the generation of output.{html,js}.mem memory initializer file. Pasing -O2, -Os or -Oz also implies –memory-init-file 1.
        emcc … -o output.{html,js} -g4 generates a source map file output.wasm.map. If targeting asm.js with -s WASM=0, the filename is output.{html,js}.map.
        emcc … -o output.{html,js} –preload-file xxx directive generates a preloaded MEMFS filesystem file output.data.
        emcc … -o output.{html,js} -s WASM={0,1} -s SINGLE_FILE=1 merges JavaScript and WebAssembly code in the single output file output.{html,js} (in base64) to produce only one file for deployment. (If paired with –preload-file, the preloaded .data file still exists as a separate file)

This list is not exhaustive, but illustrates most commonly used combinations.
Building projects with optimizations

Emscripten performs compiler optimization at two levels: each source file is optimized by LLVM as it is compiled into an object file, and then JavaScript/WebAssembly-specific optimizations are applied when converting object files into the final JavaScript/WebAssembly.

In order to properly optimize code, it is usually best to use the same optimization flags and other compiler options when compiling source to object code, and object code to JavaScript (or HTML).

Consider the examples below:

# Sub-optimal - JavaScript/WebAssembly optimizations are omitted
./emcc -O2 a.cpp -o a.bc
./emcc -O2 b.cpp -o b.bc
./emcc a.bc b.bc -o project.js

# Sub-optimal - LLVM optimizations omitted
./emcc a.cpp -o a.bc
./emcc b.cpp -o b.bc
./emcc -O2 a.bc b.bc -o project.js

# Usually the right thing: The SAME LLVM and JavaScript options are provided at both levels.
./emcc -O2 a.cpp -o a.bc
./emcc -O2 b.cpp -o b.bc
./emcc -O2 a.bc b.bc -o project.js

However, sometimes you may want slightly different optimizations on certain files:

# Optimize the first file for size, and the rest using `-O2`.
./emcc -Oz a.cpp -o a.bc
./emcc -O2 b.cpp -o b.bc
./emcc -O2 a.bc b.bc -o project.js

Note

Unfortunately each build-system defines its own mechanisms for setting compiler and optimization methods. You will need to work out the correct approach to set the LLVM optimization flags for your system.

    Some build systems have a flag like ./configure --enable-optimize.
    You can control whether LLVM optimizations are run using --llvm-opts N where N is an integer in the range 0-3. Sending -O2 --llvm-opts 0 to emcc during all compilation stages will disable LLVM optimizations but utilize JavaScript optimizations. This can be useful when debugging a build failure.

JavaScript/WebAssembly optimizations are specified in the final step (sometimes called “link”, as that step typically also links together a bunch of files that are all compiled together into one JavaScript/WebAssembly output). For example, to compile with -O1:

# Compile the linked bitcode to JavaScript with -O1 optimizations.
./emcc -O1 project.bc -o project.js

Building projects with debug information

Building a project containing debug information requires that debug flags are specified for both the LLVM and JavaScript compilation phases.

To make Clang and LLVM emit debug information in the bitcode files you need to compile the sources with -g (exactly the same as with clang or gcc normally). To get emcc to include the debug information when compiling the bitcode to JavaScript, specify -g or one of the -gN debug level options.

Note

Each build-system defines its own mechanisms for setting debug flags. To get Clang to emit LLVM debug information, you will need to work out the correct approach for your system.

    Some build systems have a flag like ./configure --enable-debug.

The flags for emitting debug information when compiling from bitcode to JavaScript are specified as an emcc option in the final step:

# Compile the linked bitcode to JavaScript.
# -g or -gN can be used to set the debug level (N)
./emcc -g project.bc -o project.js

For more general information, see the topic Debugging.
Using libraries

Built-in support is available for a number of standard libraries: libc, libc++ and SDL. These will automatically be linked when you compile code that uses them (you do not even need to add -lSDL, but see below for more SDL-specific details).

If your project uses other libraries, for example zlib or glib, you will need to build and link them. The normal approach is to build the libraries to bitcode and then compile library and main program bitcode together to JavaScript.

For example, consider the case where a project “project” uses a library “libstuff”:

# Compile libstuff to bitcode
./emconfigure ./configure
./emmake make

# Compile project to bitcode
./emconfigure ./configure
./emmake make

# Compile the library and code together to HTML
emcc project.bc libstuff.bc -o final.html

It is also possible to link the bitcode libraries first, and then compile the combined .bc file to JavaScript:

# Generate bitcode files project.bc and libstuff.bc
...

# Link together the bitcode files
emcc project.bc libstuff.bc -o allproject.bc

# Compile the combined bitcode to HTML
emcc allproject.bc -o final.html

Emscripten Ports

Emscripten Ports is a collection of useful libraries, ported to Emscripten. They reside on github, and have integration support in emcc. When you request that a port be used, emcc will fetch it from the remote server, set it up and build it locally, then link it with your project, add necessary include to your build commands, etc. For example, SDL2 is in ports, and you can request that it be used with -s USE_SDL=2. For example,

./emcc tests/sdl2glshader.c -s USE_SDL=2 -s LEGACY_GL_EMULATION=1 -o sdl2.html

You should see some notifications about SDL2 being used, and built if it wasn’t previously. You can then view sdl2.html in your browser.

Note

SDL_image has also been added to ports, use it with -s USE_SDL_IMAGE=2. To see a list of all available ports, run emcc --show-ports. For SDL2_image to be useful, you generally need to specify the image formats you are planning on using with e.g. -s SDL2_IMAGE_FORMATS='["bmp","png","xpm"]' (note: jpg support is not available yet as of Jun 22 2018 - libjpg needs to be added to emscripten-ports). This will also ensure that IMG_Init works properly when you specify those formats. Alternatively, you can use emcc --use-preload-plugins and --preload-file your images, so the browser codecs decode them (see Preloading files). A code path in the SDL2_image port will load through emscripten_get_preloaded_image_data(), but then your calls to IMG_Init with those image formats will fail (as while the images will work through preloading, IMG_Init reports no support for those formats, as it doesn’t have support compiled in - in other words, IMG_Init does not report support for formats that only work through preloading).```

Note

SDL_net has also been added to ports, use it with -s USE_SDL_NET=2. To see a list of all available ports, run emcc --show-ports.

Note

Emscripten also has support for older SDL1, which is built-in. If you do not specify SDL2 as in the command above, then SDL1 is linked in and the SDL1 include paths are used. SDL1 has support for sdl-config, which is present in system/bin. Using the native sdl-config may result in compilation or missing-symbol errors. You will need to modify the build system to look for files in emscripten/system or emscripten/system/bin in order to use the Emscripten sdl-config.
Adding more ports

Adding more ports is fairly easy. Basically, the steps are

        Make sure the port is open source and has a suitable license.
        Add it to emscripten-ports on github. The ports maintainers can create the repo and add the relevant developers to a team for that repo, so they have write access.
        Add a script to handle it under tools/ports/ (see existing code for examples) and use it in tools/ports/__init__.py.
        Add testing in the test suite.

Build system issues
Build system self-execution

Some large projects generate executables and run them in order to generate input for later parts of the build process (for example, a parser may be built and then run on a grammar, which then generates C/C++ code that implements that grammar). This sort of build process causes problems when using Emscripten because you cannot directly run the code you are generating.

The simplest solution is usually to build the project twice: once natively, and once to JavaScript. When the JavaScript build procedure fails because a generated executable is not present, you can then copy that executable from the native build, and continue to build normally. This approach was successfully used for compiling Python (see tests/python/readme.md for more details).

In some cases it makes sense to modify the build scripts so that they build the generated executable natively. For example, this can be done by specifying two compilers in the build scripts, emcc and gcc, and using gcc just for generated executables. However, this can be more complicated than the previous solution because you need to modify the project build scripts, and you may have to work around cases where code is compiled and used both for the final result and for a generated executable.
Dynamic linking

Emscripten’s goal is to generate the fastest and smallest possible code, and for that reason it focuses on generating a single JavaScript file for an entire project. For that reason, dynamic linking should be avoided when possible.

By default, Emscripten .so files are the same as .bc or .o files, that is, they contain LLVM bitcode. Dynamic libraries that you specify in the final build stage (when generating JavaScript or HTML) are linked in as static libraries. Emcc ignores commands to dynamically link libraries when linking together bitcode (i.e., not in the final build stage). This is to ensure that the same dynamic library is not linked multiple times in intermediate build stages, which would result in duplicate symbol errors.

There is experimental support for true dynamic libraries, loaded as runtime, either via dlopen or as a shared library. See that link for the details and limitations.
Configure may run checks that appear to fail

Projects that use configure, cmake, or some other portable configuration method may run checks during the configure phase to verify that the toolchain and paths are set up properly. Emcc tries to get checks to pass where possible, but you may need to disable tests that fail due to a “false negative” (for example, tests that would pass in the final execution environment, but not in the shell during configure).

Tip

Ensure that if a check is disabled, the tested functionality does work. This might involve manually adding commands to the make files using a build system-specific method.

Note

In general configure is not a good match for a cross-compiler like Emscripten. configure is designed to build natively for the local setup, and works hard to find the native build system and the local system headers. With a cross-compiler, you are targeting a different system, and ignoring these headers etc.
Archive (.a) files

Emscripten supports .a archive files, which are bundles of object files. This is an old format for libraries, and it has special semantics - for example, the order of linking matters with .a files, but not with plain object files (in .bc, .o or .so). For the most part those special semantics should work in Emscripten, however, we support .a files using llvm’s tools, which have a few limitations.

The main limitation is that if you have multiple files in a single .a archive that have the same basename (for example, dir1/a.o, dir2/a.o), then llvm-ar cannot access both of those files. Emscripten will attempt to work around this by adding a hash to the basename, but collisions are still possible in principle.

Where possible it is better to generate shared library files (.so) rather than archives (.a) — this is generally a simple change in your project’s build system. Shared libraries are simpler, and are more predictable with respect to linking.
Manually using emcc

The Emscripten Tutorial showed how emcc can be used to compile single files into JavaScript. Emcc can also be used in all the other ways you would expect of gcc:

# Generate a.out.js from C++. Can also take .ll (LLVM assembly) or .bc (LLVM bitcode) as input
./emcc src.cpp

# Generate src.o containing LLVM bitcode.
./emcc src.cpp -c

# Generate result.js containing JavaScript.
./emcc src.cpp -o result.js

# Generate result.bc containing LLVM bitcode (the suffix matters).
./emcc src.cpp -o result.bc

# Generate a.out.js from two C++ sources.
./emcc src1.cpp src2.cpp

# Generate src1.o and src2.o, containing LLVM bitcode
./emcc src1.cpp src2.cpp -c

# Combine two LLVM bitcode files into a.out.js
./emcc src1.o src2.o

# Combine two LLVM bitcode files into another LLVM bitcode file
./emcc src1.o src2.o -o combined.o

In addition to the capabilities it shares with gcc, emcc supports options to optimize code, control what debug information is emitted, generate HTML and other output formats, etc. These options are documented in the emcc tool reference (./emcc --help on the command line).
Detecting Emscripten in Preprocessor

Emscripten provides the following preprocessor macros that can be used to identify the compiler version and platform:

        The preprocessor define __EMSCRIPTEN__ is always defined when compiling programs with Emscripten.
        The preprocessor variables __EMSCRIPTEN_major__, __EMSCRIPTEN_minor__ and __EMSCRIPTEN_tiny__ specify, as integers, the currently used Emscripten compiler version.
        Emscripten behaves like a variant of Unix, so the preprocessor defines unix, __unix and __unix__ are always present when compiling code with Emscripten.
        Emscripten uses Clang/LLVM as its underlying codegen compiler, so the preprocessor defines __llvm__ and __clang__ are defined, and the preprocessor defines __clang_major__, __clang_minor__ and __clang_patchlevel__ indicate the version of Clang that is used.
        Clang/LLVM is GCC-compatible, so the preprocessor defines __GNUC__, __GNUC_MINOR__ and __GNUC_PATCHLEVEL__ are also defined to represent the level of GCC compatibility that Clang/LLVM provides.
        The preprocessor string __VERSION__ indicates the GCC compatible version, which is expanded to also show Emscripten version information.
        Likewise, __clang_version__ is present and indicates both Emscripten and LLVM version information.
        Emscripten is a 32-bit platform, so size_t is a 32-bit unsigned integer, __POINTER_WIDTH__=32, __SIZEOF_LONG__=4 and __LONG_MAX__ equals 2147483647L.
        When targeting asm.js, the preprocessor defines __asmjs and __asmjs__ are present.
        When targeting SSEx SIMD APIs using one of the command line compiler flags -msse, -msse2, -msse3, -mssse3, or -msse4.1, one or more of the preprocessor flags __SSE__, __SSE2__, __SSE3__, __SSSE3__, __SSE4_1__ will be present to indicate available support for these instruction sets.
        If targeting the pthreads multithreading support with the compiler & linker flag -s USE_PTHREADS=1, the preprocessor define __EMSCRIPTEN_PTHREADS__ will be present.

Examples / test code

The Emscripten test suite (tests/runner.py) contains a number of good examples — large C/C++ projects that are built using their normal build systems as described above: freetype, openjpeg, zlib, bullet and poppler.

It is also worth looking at the build scripts in the ammo.js project.
Troubleshooting

    Make sure to use bitcode-aware llvm-ar instead of ar (which may discard code). emmake and emconfigure set the AR environment variable correctly, but a build system might incorrectly hardcode ar.

    The compilation error multiply defined symbol indicates that the project has linked a particular static library multiple times. The project will need to be changed so that the problem library is linked only once.

    Note

    You can use llvm-nm to see which symbols are defined in each bitcode file.

    One solution is to use the dynamic-linking approach described above. This ensures that libraries are linked only once, in the final build stage.

Report Bug Licensing Contributing Mailing list Wiki Release notes Blogs Contact

    View page source
    About site
    Page bug

© Copyright 2015, Emscripten Contributors.

Logo

    Introducing Emscripten
    Getting Started
    Compiling and Running Projects
        Building Projects
        Building to WebAssembly
            Setup
            Binaryen codegen options
            Compiler output
            Testing native WebAssembly in browsers
            Debugging
            .wasm files and compilation
            Web server setup
            LLVM WebAssembly backend
        Running HTML files with emrun
        Building projects on Travis CI
        Deploying Emscripten Compiled Pages
    Porting
    API Reference
    Tools Reference
    Optimizing Code
    Optimizing WebGL
    CyberDWARF Debugging
    Building Emscripten from Source
    Contributing to Emscripten
    Profiling the Toolchain
    About this site

Index
 
Fork me on GitHub

    Documentation Downloads Community 

Home » Compiling and Running Projects » Building to WebAssembly
Building to WebAssembly

WebAssembly is a new binary format for executing code on the web, allowing much faster start times (smaller download, much faster parsing in browsers) for Emscripten projects. Emscripten supports compiling to WebAssembly with a compiler flag, so it is easy for projects to target both WebAssembly and asm.js.

For more background, see

    these slides and
    this blogpost.

Setup

WebAssembly is emitted by default, without the need for any special flags.

Note

If you don’t want WebAssembly, you can disable it with something like

emcc [..args..] -s WASM=0

Note

Emscripten’s WebAssembly support depends on Binaryen, which will be automatically fetched and built for you (you may see logging about that, the first time you compile to WebAssembly).

Note

The WASM, BINARYEN*, etc. options only matter when compiling to your final executable. In other words, the same .o files are used for both asm.js and WebAssembly. Only when linking them and compiling to asm.js or WebAssembly do you need to specify WebAssembly if you want that. That means that it is easy to build your project to both asm.js and WebAssembly.
Binaryen codegen options
Trap mode

WebAssembly can trap - throw an exception - on things like division by zero, rounding a very large float to an int, and so forth. In asm.js such things were silently ignored, as in JavaScript they do not throw, so this is a difference between JavaScript and WebAssembly that you may notice, with the browser reporting an error like float unrepresentable in integer range, integer result unrepresentable, integer overflow, or Out of bounds Trunc operation.

By default emscripten will emit code that is optimized for size and speed, which means it emits code that may trap on the things mentioned before. That mode is called allow. The other modes are clamp, which will avoid traps by clamping values to a reasonable range, and js, which ensures the exact same behavior as JavaScript does (which also does clamping, but makes sure to clamp exactly like JavaScript does, and also do other things JavaScript would).

In general, using clamp is safest, as whether such a trap occurs depends on how the LLVM optimizer optimizes code. In other words, there is no guarantee that this will not be an issue, and updating LLVM can make a problem appear or vanish (the wasm spec process has recognized this problem and intends to standardize new operations that avoid it). Also, there is not a big downside to using clamp: it is only slightly larger and slower than the default allow, in most cases. To do so, build with

    -s "BINARYEN_TRAP_MODE='clamp'"

However, if the default (to allow traps) works in your codebase, then it may be worth keeping it that way, for the (small) benefits. Note that js, which preserves the exact same behavior as JavaScript does, adds a large amount of overhead, so unless you really need that, use clamp (js is often useful for debugging, though).
Compiler output

When using emcc to build to WebAssembly, you will see a .wasm file containing that code, as well as the usual .js file that is the main target of compilation. Those two are built to work together: run the .js (or .html, if that’s what you asked for) file, and it will load and set up the WebAssembly code for you, properly setting up imports and exports for it, etc. Basically, you don’t need to care about whether the compiled code is asm.js or WebAssembly, it’s just a compiler flag, and otherwise everything should just work (except the WebAssembly should be faster).

    Note that the .wasm file is not standalone - it’s not easy to manually run it without that .js code, as it depends on getting the proper imports that integrate with JS. For example, it receives imports for syscalls so that it can do things like print to the console. There is work in progress towards ways to create standalone .wasm files, see the WebAssembly Standalone page.

You may also see additional files generated, like a .data file if you are preloading files into the virtual filesystem. All that is exactly the same as when building to asm.js. One difference you may notice is the lack of a .mem file, which for asm.js contains the static memory initialization data, which in WebAssembly we can pack more efficiently into the WebAssembly binary itself.
Testing native WebAssembly in browsers

WebAssembly support is enabled by default as of Firefox 52, Chrome 57 and Opera 44. On Edge 15 you can enable it via “Experimental JavaScript Features” flag.
Debugging

asm.js support is considered very stable now, and you can change between it and wasm with -s WASM=1, so if you see something odd in a wasm build, comparing to a parallel asm.js build can help. In general, any difference between the two could be a compiler bug or browser bug, but there are a few legitimate causes of different behavior between the two, that you may want to rule out:

    wasm allows unaligned accesses, i.e. it will load 4 bytes from an unaligned address the same way x86 does (it doesn’t care it’s unaligned). asm.js works more like ARM CPUs which mostly don’t accept such things (but they often trap, while asm.js just returns a wrong result). To rule this out, you can build with -s SAFE_HEAP=1, that will catch all such invalid accesses.
    Timing issues - wasm might run faster or slower. To some extent you can mitigate that by building with -s DETERMINISTIC=1.
    Trap mode. As mentioned above, we can generate wasm that traps or that avoids traps. Make sure the trap mode is "js" when comparing builds. The "js" trap mode is also useful in a single build, as otherwise operations like division or float-to-int may trap, and the optimizer may happen to change whether a trap occurs or not, which can be confusing (for example, enabling SAFE_HEAP may prevent some optimizations, and a trap may start to occur). Instead, in the "js" trap mode there are no traps and all operations are deterministically defined as identical to JavaScript.
    Minor libc and runtime differences exist between wasm and asm.js. We used to have a way to emit more compatable builds (-s "BINARYEN_METHOD='asmjs,native-wasm'" etc.) but due to its complexity and low value it was removed.
    Floating-point behavior: WebAssembly uses 32-bit floats in a standard way, while asm.js by default implements floats using doubles. That can lead to differences in the precision of results. You can force 32-bit float behavior in asm.js with -s PRECISE_F32=1, in which case it should be identical to wasm.
    Browser instability: It’s worth testing multiple browsers, as one might have a wasm bug that another doesn’t. You can also test the Binaryen interpreter (e.g. using the interpret-binary method, as discussed above).

If you find that an asm.js build has the same behavior as a wasm one, then it is currently easier to debug the asm.js build: you can edit the source easily (add debug printouts, etc.), there is debug info and source maps support, etc.
Debugging WebAssembly

When you do need to debug a WebAssembly build, the following tips might help you.

WebAssembly doesn’t have source maps support yet, but building with -g will emit both a text and a binary wasm, and it will include function names in both, and also include source file and line number information in the text, for example, building hello world might have this in the .wast:

;; tests/hello_world.c:4
(drop
  (call $_printf
    (i32.const 1144)
    (get_local $$vararg_buffer)
  )
)
;; tests/hello_world.c:5
(return
  (i32.const 0)
)

This indicates that the printf call comes from line 4, and the return from line 5, of hello_world.c.
.wasm files and compilation

WebAssembly code is prepared somewhat differently than asm.js. asm.js can be bundled inside the main JS file, while as mentioned earlier WebAssembly is a binary file on the side, so you will have more than one file to distribute.

Another noticeable effect is that WebAssembly is compiled asynchronously by default, which means you must wait for compilation to complete before calling compiled code (by waiting for main(), or the onRuntimeInitialized callback, etc., which you also need to do when you have anything else that makes startup async, like a .mem file for asm.js, or preloaded file data, etc.). You can turn off async compilation by setting BINARYEN_ASYNC_COMPILATION=0, but that may not work in Chrome due to current limitations there.

    Note that even with async compilation turned off, fetching the WebAssembly binary may need to be an asynchronous operation (since the Web does not allow synchronous binary downloads on the main thread). If you can fetch the binary yourself, you can set Module['wasmBinary'], and that will be used synchronously.

Web server setup

To serve wasm in the most efficient way over the network, make sure your web server has the proper MIME time for .wasm files, which is application/wasm. That will allow streaming compilation, where the browser can start to compile code as it downloads.

In Apache, you can do this with

AddType application/wasm .wasm

Also make sure that gzip is enabled:

AddOutputFilterByType DEFLATE application/wasm

If you serve large .wasm files, the webserver will consume CPU compressing them on the fly at each request. Instead you can pre-compress them to .wasm.gz and use content negotiation:

Options Multiviews
RemoveType .gz
AddEncoding x-gzip .gz
AddType application/wasm .wasm

LLVM WebAssembly backend

The steps in the previous section all use Binaryen’s asm2wasm tool to compile asm.js to WebAssembly. This option is considered stable as it passes the test suite.

There is an LLVM backend being developed for WebAssembly. Emscripten has support for it, and hopes to enable it by default in the future, but currently it is not yet good enough for that (as it is still being stabilized, and generates less compact code).

To use the LLVM wasm backend, build with something like

EMCC_WASM_BACKEND=1 emcc -s WASM=1 input.cpp [..]

The EMCC_WASM_BACKEND env var tells Emscripten to use the wasm backend.

Note that when using the WebAssembly backend in this manner, you do not actually need Emscripten’s asm.js backend, which means you don’t need Emscripten’s “fastcomp” fork of LLVM. Instead you must use “vanilla” LLVM (that is, pure upstream LLVM, with no Emscripten additions).

    When doing so, you do not need the EMCC_WASM_BACKEND=1 env var, as emcc will detect the lack of the asm.js backend and infer it must use the wasm backend. (However, you can still set it, and it’s a little faster, since it avoids the check).
    Edit LLVM_ROOT in ~/.emscripten so that it points to the bin directory of your custom LLVM build.

Report Bug Licensing Contributing Mailing list Wiki Release notes Blogs Contact

    View page source
    About site
    Page bug

© Copyright 2015, Emscripten Contributors.

Logo

    Introducing Emscripten
    Getting Started
    Compiling and Running Projects
        Building Projects
        Building to WebAssembly
        Running HTML files with emrun
            Features
            Quick how-to
            Choosing the browser to run
            Security implications
            Controlling web server operation
            Controlling log output
            Cleaning up after the run
            Running web pages in Firefox
            Running web pages on an Android device
        Building projects on Travis CI
        Deploying Emscripten Compiled Pages
    Porting
    API Reference
    Tools Reference
    Optimizing Code
    Optimizing WebGL
    CyberDWARF Debugging
    Building Emscripten from Source
    Contributing to Emscripten
    Profiling the Toolchain
    About this site

Index
 
Fork me on GitHub

    Documentation Downloads Community 

Home » Compiling and Running Projects » Running HTML files with emrun
Running HTML files with emrun

emrun is a command line tool that can run generated HTML pages via a locally launched web server. This is helpful when using web browsers that cannot run a generated .html file via a file:// URL (e.g. by double-clicking the file) because of the default browser CORS rules.

emrun also enables all kinds of command-line automation, for example, integrating unit tests into an Emscripten environment in a project build farm.
Features

emrun supports the following uses:

    Launch your Emscripten-generated HTML page in a web browser from the command line.
    Capture application stdout and stderr streams during the run, and print them to a terminal or log them to a file.
    Pass command-line arguments to the application and read them from GET parameters in the launched URL, or argc and argv in main().
    Detect when a launched application quits via a call to C’s exit(returncode), then pass the specified return code to the terminal.
    Choose which installed browser to run, or even run a browser on an Android device connected to the local computer through adb.

Quick how-to

Using emrun is simple:

    Rebuild your Emscripten application and add the --emrun linker flag.

    This flag injects code into the generated Module object to enable capture of stdout, stderr and exit().

    Note

    If you skip this step, you can still run any .html file with emrun, but the capture will not work.

    Open a terminal, navigate to the build output directory, and call emrun page.html.

    This will spawn a new web server to host the page and launch your default system browser to visit that page. emrun will block until the page calls exit(returncode), after which it will quit back to shell with the given process exit code.

Choosing the browser to run

The --browser <filename-or-browser-alias> command line option allows you to launch an HTML file using a particular browser, by specifying either its “browser alias” or the full path to its executable (if the flag is not specified, the default system browser is launched).

To enumerate the list of browser aliases on your system, use the --list_browsers command:

> emrun --list_browsers

emrun has automatically found the following browsers in the default install locations on the system:

- firefox: Mozilla Firefox 26.0.0.5087
- firefox_beta: Mozilla Firefox 26.0.0.5077
- firefox_aurora: Mozilla Firefox Aurora 28.0.0.5098
- firefox_nightly: Mozilla Firefox Nightly 29.0.0.5098
- chrome: Google Chrome 31.0.1650.63
- chrome_canary: Google Chrome 34.0.1752.0
- iexplore: Microsoft Internet Explorer 11.0.9600.16384
- opera: Opera 18.0.1284.63

Note

For your browser to be detected, it should be installed in the default install location on the system (%ProgramFiles% on Windows and /Applications/ on macOS) or by adding it to the PATH for the current user.

You can pass the --browser <alias> option to launch with a given browser. For example, to run the Firefox Nightly browser you would call:

emrun --browser firefox_nightly page.html

To launch using a browser’s filename use:

--browser /path/to/browser/executable page.html

If you just want to launch a web server you can pass the --no_browser command line flag. In this case emrun will run the server without spawning the browser (this is similar to using Python’s SimpleHTTPServer).
Security implications

emrun spawns its own web server to host the target .html file. This has the following security implications:

    The web server is a generic file server that by default serves all files in the directory where the .html file resides, and all directories under that directory tree.
    The web server will be visible to other computers on the same network.

Controlling web server operation

The following command line flags control how emrun spawns the web server:

    --no_server: Do not launch a web server. The target file is run via the file:// protocol, if possible.
    --serve_after_close: Do not quit emrun; continue running the server even after the user closes the web browser. Use this flag when you want to visit the page multiple times or with different browsers during the same run.
    --serve_after_exit: Do not quit emrun; continue running the server after the page finishes with a call to exit(returncode).
    --serve_root <path>: Specify a custom directory to use as the root directory for the spawned web server. By default, the directory where the .html file resides is used.
    --port <number>: Specify the web server TCP port. The default port is 6931.
    --silence_timeout <seconds>: Specify the emrun silence timeout. If the application does not print anything to stdout or stderr in this many seconds, the page/browser is assumed to be hung, and emrun will quit. This is disabled by default.
    --timeout <seconds>: Specify the emrun timeout. If the whole page run lasts longer than this many seconds, the page/browser is assumed to be hung, and emrun will quit. This is disabled by default.
    --hostname <name>: Specify the web server TCP hostname. The default hostname is localhost.
    --timeout_returncode <code>: Specifies the process return code that emrun quits with if a page run timeout occurs. By default this is 99999.

Controlling log output

The following command line flags affect logging output:

    --verbose: Print detailed information about emrun internal steps.
    --log_stdout <filename>: Write all stdout messages from the application to the named file (instead of printing to terminal).
    --lot_stderr <filename>: Write all stderr messages from the application to the named file (instead of printing to terminal).
    --system_info: Print detailed information about the current system before launching. This is useful during automated runs when you want to capture hardware information to logs.
    --browser_info: Print information about which browser is about to be launched.
    --log_html: Reformat application output as HTML markup.
    --no_emrun_detect: Hide the warning message that is launched if a target .html file is detected to not have been built with --emrun.

Cleaning up after the run

These command line flags allow you to clean up open browser processes before starting a new run — this is important for automated testing on build servers:

    --kill_start: Terminate all instances of the target browser process before starting the run. Pass this flag to ensure that no old (hung) instances of the target browser process exist that could interfere with the current run. This is disabled by default.
    --kill_exit: Terminate all instances of the target browser process when emrun quits. Pass this flag to ensure that browser pages closed when the run is over. This is disabled by default. Note that it may be necessary to explicitly use the --browser=/path/to/browser command line option when using --kill_exit, or otherwise the termination might not function properly.

Warning

These operations cause the browser process to be forcibly terminated. Any windows or tabs you have open will be closed, including any that might contain unsaved data.
Running web pages in Firefox

When running web pages via emrun using Firefox, you may want to set one or more of the following browser prefs:

; Make sure to unblock popups being spawned from http://localhost/.
browser.popups.showPopupBlocker;false

; Don't ask the user to change the default browser when spawning the browser.
browser.shell.checkDefaultBrowser;false

; Don't autorestore previous tabs, just open the one from the command line.
browser.sessionstore.resume_from_crash;false
services.sync.prefs.sync.browser.sessionstore.restore_on_demand;false
browser.sessionstore.restore_on_demand;false

; Don't bring up the modal "Start in Safe Mode" dialog after browser is killed, since
; that is an expected path for --kill_start and --kill_exit options.
browser.sessionstore.max_resumed_crashes;-1
toolkit.startup.max_resumed_crashes;-1

; Don't fail on long-running scripts, but have emrun instead control execution termination.
dom.max_script_run_time;0
dom.max_chrome_script_run_time;0

; Accelerate browser update background timer tick so that autoupdates take place as quickly as possible.
; This is useful for continuous integration servers wanting to always test the latest browser version.
app.update.download.backgroundInterval;1

; Always run in private browsing mode to avoid caching any pages (but also disables IndexedDB persistency!).
browser.privatebrowsing.autostart;true

; When switching between multiple Firefox browser versions/channels, suppress showing the first time welcome page.
startup.homepage_override_url;about:blank
startup.homepage_welcome_url;about:blank

To set a Firefox browser pref, navigate to the page about:config in the browser navigation bar.
Running web pages on an Android device

emrun can automate browser-based testing on Android.

For this to work, you need to:

    Connect an Android phone to the local system via USB, with its developer mode enabled. There is no need to root the phone.
    Install the adb tool on the host system and make sure it is present in the PATH environment variable.
    Check that adb is working by calling adb devices to see that your device is listed.
    Install any browser apk to the device that you want to be able to run.

To run on Android, add the --android command line flag and use the --browser <alias> command line flag to explicitly choose the correct browser to run.

Note

Omitting --browser (to launch a default Android browser) is not supported.

Note

Running on Android will omit the --hostname option

The following browser aliases have been tested and shown to work: firefox, firefox_beta, firefox_aurora, firefox_nightly, chrome, chrome_beta, opera.

The following browser aliases are also supported, but have known issues:

    opera_mini: The browser launches, but for some reason it times out when trying to load any page.
    dolphin: Works, but does not support WebGL.

Otherwise, using emrun for browser-based testing on Android is the same as when testing on the host system.
Report Bug Licensing Contributing Mailing list Wiki Release notes Blogs Contact

    View page source
    About site
    Page bug

© Copyright 2015, Emscripten Contributors.

Logo

    Introducing Emscripten
    Getting Started
    Compiling and Running Projects
        Building Projects
        Building to WebAssembly
        Running HTML files with emrun
        Building projects on Travis CI
            A sample .travis.yml
        Deploying Emscripten Compiled Pages
    Porting
    API Reference
    Tools Reference
    Optimizing Code
    Optimizing WebGL
    CyberDWARF Debugging
    Building Emscripten from Source
    Contributing to Emscripten
    Profiling the Toolchain
    About this site

Index
 
Fork me on GitHub

    Documentation Downloads Community 

Home » Compiling and Running Projects » Building projects on Travis CI
Building projects on Travis CI

Travis CI is a popular continuous integration service which offers free plans for open source projects. Thanks to a Docker image by trzeci installing emscripten in Travis CI is essentially a one line task.
A sample .travis.yml

notifications:
  email: false

language: node_js
node_js:
  - node

sudo: required

services:
  - docker

before_install:
  - docker run -dit --name emscripten -v $(pwd):/src trzeci/emscripten:sdk-incoming-64bit bash

script:
  - docker exec -it emscripten make helloworld.js
  - make test

Let’s break it down:

notifications:
  email: false

language: node_js
node_js:
  - node

sudo: required

services:
  - docker

These lines set up the basic settings for the Travis container. Most people do not want email notifications, but feel free to leave out those lines if you do.

language: node_js and node_js: - node tell Travis we are a Node.js project, and that we want the latest stable Node release.

sudo: required and services: - docker are required to enable Docker in the Travis container.

before_install:
  - docker run -dit --name emscripten -v $(pwd):/src trzeci/emscripten:sdk-incoming-64bit bash

In the before_install stage we download the Docker image, create a container with that image, and then give it the name emscripten. The -dit options tell Docker that we want the container to run bash in the background.

This Docker image contains everything emscripten needs to run, as well as several additional build tools such as make and cmake. If you do not need them you can use the emscripten-slim image instead, which excludes them and will be downloaded and installed slightly quicker. The emscripten versions available are listed at the Docker Hub.

script:
  - docker exec -it emscripten make helloworld.js
  - make test

In the script stage we can now run the commands we want, inside the Docker container we created earlier. In this sample we are using make, but you can call emcc directly if you prefer.

The Docker container is set up to use the same directories as Travis, so the second line uses the same Makefile, and can also depend on the output of the Docker command. If your test suite needs a later version of Node than what is installed by emsdk (Node v4), you will need to run the tests outside of Docker as a normal Travis command.

For an example of this setup in practice, see the Travis page for emglken, which is also set up to use Greenkeeper for automatic testing of dependency updates.
Report Bug Licensing Contributing Mailing list Wiki Release notes Blogs Contact

    View page source
    About site
    Page bug

© Copyright 2015, Emscripten Contributors.

Logo

    Introducing Emscripten
    Getting Started
    Compiling and Running Projects
        Building Projects
        Building to WebAssembly
        Running HTML files with emrun
        Building projects on Travis CI
        Deploying Emscripten Compiled Pages
            Build Files and Custom Shell
            Optimizing Download Sizes
            Optimizing Page Startup Times
            Providing a Quick Second Time Load
            Reserving Memory for Compiled Code
            Robust Error Handling
            Prepare for The Web Environment
    Porting
    API Reference
    Tools Reference
    Optimizing Code
    Optimizing WebGL
    CyberDWARF Debugging
    Building Emscripten from Source
    Contributing to Emscripten
    Profiling the Toolchain
    About this site

Index
 
Fork me on GitHub

    Documentation Downloads Community 

Home » Compiling and Running Projects » Deploying Emscripten Compiled Pages
Deploying Emscripten Compiled Pages

Emscripten compiled output can either be run directly in a JS shell from command line, or hosted on a web page. When hosting asm.js and WebAssembly compiled pages as .html for browsers to execute, Emscripten provides a default HTML shell file that serves as a launcher to run the code, simplified to get started with development. However when getting ready to release and host the content on a web site, a number of extra features and customizations are likely needed to polish the visitor experience. This guide highlights things to pay attention to when deploying sites to the public.
Build Files and Custom Shell

Emscripten build output consists of two essential parts: 1) the low level compiled code module and 2) the JavaScript runtime to interact with it. If targeting WebAssembly which is done with linker flags -s WASM=1 -o out.html, the compiled code is stored in a file out.wasm and the runtime lives in a file out.js. When targeting asm.js there exists an additional binary file out.mem that contains the static memory section of the compiled code. This part is embedded in the out.wasm file when targeting WebAssembly.

By default when targeting asm.js, the compiled code and the runtime are fused in the same out.js file. For moderately large asm.js projects, it is recommended to use the --separate-asm flag to separate the compiled code to its own out.asm.js file, which enables browsers to optimize memory usage for the compiled asm.js code.

Additional build output files can also exist, depending on which features are used. If the Emscripten file packager is used, a binary out.data package is generated, along with an associated out.data.js loader file. Also Emscripten pthreads and Fetch APIs have their own associated Web Worker related script .js output files.

Developers can choose to output either to JavaScript or HTML. If outputting JavaScript (emcc -o out.js), the developer is expected to manually create the out.html main page in which the code is run in browsers. When targeting HTML with emcc -o out.html (the recommended build mode), Emscripten will generate the HTML shell file automatically. This shell file can be customized by using the emcc -o out.html --shell-file path/to/custom_shell.html linker directive. Copy the default minimal HTML shell file from Emscripten repository to your project tree to get a good starting template for a customized shell file.

The following sections offer tips for improving the site experience.
Optimizing Download Sizes

The biggest slowdown to speedy page loading is most often the need to download large amounts of asset data for the project, especially if the page is heavy on WebGL textures or geometry. Compiled code generally takes up more space than handwritten JavaScript, but machine code compresses efficiently. Therefore when hosting asm.js and WebAssembly, it is critical to ensure that all content is transferred using gzip compression, which all browsers and CDNs nowadays support built-in. Gzip compressing .wasm files give on average 60-75% size reductions compared to uncompressed ones, so it practically never makes sense to serve uncompressed files.

    To serve gzip-compressed assets on a CDN, use a gzip compression tool and precompress asset files offline before uploading to the CDN. Some web servers support compressing files on the fly, but for static asset content, that should be avoided since it can be costly for the server CPU to keep recompressing the files. Adjust the configuration of the web server to host the precompressed files with the HTTP response header Content-Encoding: gzip. This instructs web browsers that the downloaded content should be transparently uncompressed before handing the data off to the page itself.
    WebAssembly has now shipped in Firefox 52 and Chrome 57. Emscripten also supports targeting WebAssembly, by using the -s WASM=1 linker flag. WebAssembly is an evolution of asm.js, and if your project already successfully compiles to asm.js, it is likely to already work with WebAssembly as well. Compressed WebAssembly output files can be around 20% smaller than compressed asm.js files, but for builds with debugging and profiling information, the difference can even be up to 50%, so the benefit is large.
    Make sure that gzip compression does not confuse the MIME types that the assets are served with. All JavaScript files (precompressed or not) should be best served with the HTTP response header Content-Type: application/javascript, and all asset files (.data, .mem) should be served with the header Content-Type: application/octet-stream. WebAssembly .wasm files should be served with Content-Type: application/wasm.
    Try to minimize the amount of preloaded asset data that is downloaded up front with the Emscripten --preload-file linker flag. This data file is loaded up before the Emscripten compiled application starts to execute main() function at all, so all files that are stored in this package can greatly slow down the time to start up. Prefer to break up downloaded asset files to multiple separate packages and using asynchronous asset download APIs in Emscripten which can operate while the application is running.
    Asset sizes for WebGL applications are often dominated by the amount of textures, such that using compressed texture formats helps to shrink down asset sizes. The web can be quite a different platform to target compared to native platforms, since on the web one cannot necessarily assume that a specific compressed texture format would be supported on the visitor’s hardware, especially if developing a site that should work both on mobile and desktop browsers. The best practice to support a wide range of hardware is to generate multiple sets of compressed textures, one for each supported platform, and download the appropriate one based on the formats that the WebGL context supports.
    If multiple screen sizes are being targeted, e.g. in desktop and mobile form factors, consider separating textures out to SD and HD variants to make the page load up quicker for mobile devices that have a smaller display resolution.

Optimizing Page Startup Times

In addition to downloading the page, other parts of the startup sequence can sometimes also be slow. Things to consider here are:

    If targeting asm.js and running on Firefox or Edge, the web page console displays a log message after the asm.js module has been compiled. This log message includes timing information about how long the compilation took. Asm.js compilation begins the moment the asm.js script source file is added to the DOM, and once it finishes, the onload event of the script tag is called. This can be used to time how long asm.js compilation takes on Safari, Opera and Chrome.
    It is recommended to migrate to WebAssembly to speed up compiled code startup times in browsers. WebAssembly modules are much faster to parse and compile compared to asm.js. Additionally, compiled WebAssembly.Module objects can be manually persisted to IndexedDB, which avoids the compilation step altogether on the second run. (see next section)
    Occassionally it can be easy to misattribute slow startup to asm.js/WebAssembly compilation, when the actual cause of slowness can in fact be in executing the main() function entry point of the application itself. This is because these two actions are run closely back to back to each other. It is worthwhile to be precise to profile these two actions separately, check out the function callMain() in src/preamble.js which kicks off the execution of application main() code. If executing main() takes too long time, consider splitting it out to separate operations that are driven by multiple setTimeout() calls or by the emscripten_set_main_loop() event loop.
    To speed up network transfers, experience shows that the under regular network conditions, the fastest approach is to aggressively start all network downloads simultaneously in parallel (assuming there are only a handful of them), as opposed to e.g. downloading a single input file at a time before starting the next one. Therefore to maximize network transfer speed, try to write the main HTML page of the application to start all needed network downloads in parallel instead of queueing them up for sequential transfer.
    In the case when the first time load of the page is dominated by network transfers, it is useful to take advantage of the fact that the CPU is otherwise mostly idle while waiting for downloads to finish. This CPU time can be utilized to perform other heavy tasks. An ideal candidate for this is to download and compile the asm.js/WebAssembly module already while downloading other page assets.
    A currently known issue on Windows based systems is that compiling WebGL shaders can be slow. This is also a primary candidate for an action to be performed in parallel while downloading other assets for the page.

Providing a Quick Second Time Load

While the first run experience of visiting a page can take some time to finish all downloads, the second run experience of the page can be made much faster by making sure that the results of the first visit are cached by the browser.

    All browsers have an implementation defined limit (20MB or 50MB) for assets, and files larger than that will bypass the browser’s built-in web caches altogether. Therefore it is recommended that large .data files are manually cached to IndexedDB by the main page. The Emscripten linker option --use-preload-cache can be used to have Emscripten implement this, although it can be desirable to manually manage this on the html page in a custom manner, since that allows taking control of which database the assets are cached to, and what kind of scheme will be used to evict data from it.
    Compilation results of asm.js modules are cached automatically by the browser, and there is little control over this. WebAssembly on the other hand supports explicit caching of compiled WebAssembly.Module objects to IndexedDB. This feature should be always leveraged, since it allows skipping the whole compilation process on the second page visit.
    If the compiled C/C++ code itself performs any computation e.g. in main() that could be skipped on the second load, use either IndexedDB or the localStorage APIs to cache the results of this computation across page runs. IndexedDB is suitable for storing large files, but it works asynchronously. The localStorage API on the other hand is fully synchronous, but its usage is restricted to storing small cookie style data fields only.
    When implementing IndexedDB based caching, it is good to note that as an asynchronous API that performs disk accesses, IndexedDB operations have some latency as well. Therefore if performing multiple read operations at startup, it is good to fire all of them up in parallel where possible, to reduce latency.
    Another important point with persisting data is that for best practices towards the user, it is good to provide an explicit visual identification when using IndexedDB or localStorage to persist large amounts of data, and offer an easy mechanism to clear or uninstall that data. This is because currently browsers do not implement convenient UIs for fine grained deletion of data from these storages, but clearing data often is presented as a “clear cache from all pages” type of option.

Reserving Memory for Compiled Code

An inherent property of asm.js and WebAssembly applications is that they need a linear block of memory to represent the application heap. This is often the single largest memory allocation that an Emscripten compiled page does, and therefore is the one that is at the biggest risk of failing if the user’s system is low on memory.

Because this memory allocation needs to be contiguous, it can happen that the user’s browser process does have enough memory, but only the address space of the process is too fragmented, and there is not enough linear address space available to satisfy the allocation. To avoid this issue, the best practice is to allocate the WebAssembly.Memory object (ArrayBuffer for asm.js) up front at the top of the main page, before any other allocations or page script load actions are done. This ensures that the allocation has best chances to succeed. See the fields Module['buffer'] and Module['wasmMemory'] for more information.

Additionally, it is possible to opt in to content process isolation specifically for a web page that needs this kind of a large allocation. To utilize this machinery, specify the HTTP response header Large-Allocation: <MBytes> when serving the main html page. This support is currently implemented in Firefox 53.

Last, it is easy to accidentally cling to large unneeded blocks of memory after the page has loaded. For example, in WebAssembly, once the WebAssembly Module has been instantiated to a WebAssembly.Instance object, the original WebAssembly.Module object is no longer needed in memory, and it is best to clear all references to it so that the garbage collector can reclaim it, because the Module object can be dozens of megabytes in size. Similar, make sure that all XHRed files, asset data and large scripts are not referenced anymore when not used. Check out the browser’s memory profiling tool, and the about:memory page in Firefox to perform memory profiling to ensure that memory is not being wasted.
Robust Error Handling

To provide the best possible user experience, make sure that the different ways that the page can fail are taken into account, and good error reporting is provided to the user. In particular, proceed through the following checklist for best practices.

    Aim to fail as early as possible. A large source of frustration for users comes from scenarios where user’s system is not ready to run the given page, but the error only becomes apparent after having waited for a minute to download 100MB worth of assets. For example, try to allocate the needed heap memory up front before actually loading up the page. This way if the memory allocation fails, the failure is immediate and no asset downloads need to be attempted at all.

    If a particular browser is known to not be supported, resist the temptation to read navigator.userAgent field to gate users with that browser, if at all possible. For example, if your page needs WebGL 2 but Safari is known not to support it, do not exclude out Safari users with a following type of check:

        if (navigator.userAgent.indexOf('Safari') != -1) alert('Your browser does not support WebGL 2!');

but instead, detect the actual errors:

    if (!canvas.getContext('webgl2')) alert('Your browser does not support WebGL 2!'); // And look for webglcontextcreationerror here for an error reason.

This way the page will be future compatible once support for the particular feature later becomes available.

    Test various failure cases up front by simulating different issues and browser limitations. For example, on Firefox, it is possible to manually disable WebGL 2 by navigating to about:config and setting the preference webgl.enable-webgl2 to false. This allows you to debug what kind of error reporting your page will present to the user in such a scenario. To disable WebGL support altogether for testing purposes, set the preference webgl.disabled to true.

    When working with IndexedDB, prepare to handle out of quota errors when user is about to run out of free disk space or allowed quota for the domain.

    Simulate out of memory errors by allocating unrealistically much memory for WebAssembly.Memory object and for the preloaded file packages, if using any. Make sure that out of memory errors are flagged correctly as such (and reported to the user or to an error database).

    Simulate download timeouts either intrusively by programmatically aborting XHR downloads, physically disconnecting network access, or by using external tools such as Fiddler. These types of tools can show up a lot of unexpected failure cases and help diagnose that the error handling path for such scenarios is as desired.

    Use a network limiter tool to constrain download or upload bandwidth speeds to simulate slow network connections. This can uncover bugs related to timing dependencies for network transfers. For example, a small network transfer may be implicitly assumed to finish before a large one, but that might not always be the case.

    When developing the page locally, perform testing by using a local web server and not just via file:// URLs. The script emrun.py in Emscripten source tree is designed to serve as an ad hoc web server for this purpose. Emrun is preconfigured to handle serving gzip compressed files (with suffix .gz), and enables support for the Large-Allocation header, and allows command line automation runs of compiled pages.

    Catch all exceptions that come from within entry points that call to compiled asm.js and WebAssembly code. There are three distinct exception classes that compiled code can throw:

            C++ exceptions that are represented by a thrown integer and not caught by the C++ program. This integer points to a memory location in the application heap that contains pointer to the thrown object.
            Exceptions caused by Emscripten runtime calling the abort() function. These correspond to a fatal error that execution of the compiled code cannot recover from. For example, this can occur when calling an invalid function pointer.
            Traps caused by compiled WebAssembly code. These correspond to fatal errors coming from the WebAssembly VM. This can occur for example when performing an integer division by zero, or when converting a large floating point number to an integer when the float is out of range of the numbers representable by that integer type. See the linker flag -s BINARYEN_TRAP_MODE for more details.

    Implement a final “catch all” error handler on the page by implementing a window.onerror script. This will be called as a last resort if no other source handled an exception that was raised on the page. See window.onerror documentaton on MDN.

    Do not let the html page “freeze” and bury the error message in the web page console, because most users will not know how to find it there. Strive to provide meaningful error reports to the user on the main html page, preferably with hints on how to act. If updating a browser version or GPU drivers, or freeing up some space on disk might have a chance to help the page to run, let the user know what they could try out. If the error in question is completely unexpected, consider providing a link or an email address where to report the issue to.

    Provide meaningful and interactive loading progress indicators to show the user whether the loading progress is still proceeding and what is going to happen next. Try to prevent leading the user to a “I wonder if it is still loading or if it hung?” state of mind.

Prepare for The Web Environment

When planning a testing matrix before pushing a site live, the following items can be a good idea to review.

    Web page behavior can be subtly different when run as a top level window vs when run in an iframe. Make sure to test both scenarios if these are applicable.
    Test both 32 bit and 64 bit browsers, especially simulate out of memory scenarios on 32 bit browsers.
    Be aware of the HTTP Cross-Origin Access Control rules and how they pertain to the site architecture you are hosting.
    Be aware of the Content Security Policy rules and make note of what kind of CSP policy the site is planned to run with.
    Be mindful of the Mixed Content Security restrictions that browsers impose.
    Make sure that the site runs well in private browsing (incognito) mode. For example, this will prevent the site from persisting data to IndexedDB.
    Test that the page works well when put into a background tab. Use the blur, focus and visibilitychange DOM events to react to page hide and show events. This is relevant in particular for applications that perform audio playback.
    If the page uses WebGL, make sure that it is able to gracefully handle the WebGL context loss event. Use the WebGL_lose_context developer extension to programmatically trigger context loss events when testing.
    Verify that the page works as intended on displays with different window.devicePixelRatio (DPI) settings, in particular when using WebGL. See Khronos.org: HandlingHighDPI. On Windows and macOS, try changing the desktop display scaling setting to test different values of window.devicePixelRatio that the browser reports.
    Test out that different page zoom levels do not break the site layout, especially when navigating to the page with the browser window already pre-zoomed.
    Likewise, verify that the page layout does not break when resizing the browser window, or when visiting the site having already initially sized the browser window to very small or large size, or to a disproportionate aspect ratio.
    Especially if targeting mobile, be aware of the <meta viewport> tag for how to develop a site layout that works well on mobile.
    If the page uses WebGL, test out different GPUs on target platforms. In particular, verify the site behavior when simulating the lack of any needed WebGL extensions, and compressed texture format support.
    If using the requestAnimationFrame() API (i.e. emscripten_set_main_loop() function) to drive rendering, be aware that the rate at which the function is called is not always 60 Hz, but can vary at runtime e.g. when moving the browser window from one display to another in a multimonitor setup, if the displays have different refresh rates. Update intervals such as 75Hz, 90Hz, 100Hz, 120Hz, 144Hz and 200Hz are becoming more common.
    Simulate lack of any special APIs that the page might need, e.g. Gamepad, Acceleration or Touch Events, and make sure that appropriate error flow is handled in those cases as well.

If you have good tips or suggestsions to share, please help improve this guide by posting feedback to the Emscripten bug tracker or the emscripten-discuss mailing list.
Report Bug Licensing Contributing Mailing list Wiki Release notes Blogs Contact