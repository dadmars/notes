## 选择排序

* 找到数组中最小的元素
* 与数组第一个元素交换位置
* 在剩下元素中找到最小的与第2个元素交换位置，反复

## 插入排序

* 将元素插入到合适位置
* 当前索引左边的都是有序的，为给更小的元素膦位置，元素可能移动

## 希尔排序

使数组中任意间隔为h的元素都是有序的。

## 桶排序

输入： 0-n

* 大小为 n 的数组，初始化为0
* 当输入 a, val[a] += 1
* 输出数组：
  * val[a] == 0 略过
  * val[a] == 3 输出 3 个 a

O(M + N) M: 数组大小， N: 要排列的数的个数

## 冒泡排序

每次比较两个相邻元素，如果它们顺序错误，则进行交换

O(N**2)

## 快速排序

* 选一基准数a
* 从左出发，找到第一个 < a 的位置。从右出发，找到第一个 > a 的位置，两位置的值交换。继续到左右相遇。
* 左边的和右边的重复上面两步

小数组的插入排序快与快速排序 5-15 的数量

三取样切分： 子数组的一小部分的中位数切分数组。取样大小为 3

切分为大于，小于，等于三个部分，应对大量重复数据的情况。将相等的换到中间。

O(NlogN)

## 深度优先遍历

从一个未访问过的点为起始顶点，沿当前顶点的边走到未访问过的顶点。当没有未访问的顶点，返回上一个顶点，继续试探访问其它顶点，直到所有顶点都被访问。

沿图的一条分支遍历直到末端，然后返回，再沿另一条同样遍历。

## 广度优先遍历

从一个未访问过的点为起始顶点，访问其所有相邻顶点。然后对每个相邻顶点,再访问它们相邻的未访问的顶点

## 动态规划

将问题分为子问题，计算子问题的解并记录